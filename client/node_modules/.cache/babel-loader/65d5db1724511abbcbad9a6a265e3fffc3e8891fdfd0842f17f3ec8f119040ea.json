{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n  return to;\n};\nvar EventEmitter = require('./eventemitter');\nvar RemoteAudioTrack = require('./media/track/remoteaudiotrack');\nvar RemoteAudioTrackPublication = require('./media/track/remoteaudiotrackpublication');\nvar RemoteDataTrack = require('./media/track/remotedatatrack');\nvar RemoteDataTrackPublication = require('./media/track/remotedatatrackpublication');\nvar RemoteVideoTrack = require('./media/track/remotevideotrack');\nvar RemoteVideoTrackPublication = require('./media/track/remotevideotrackpublication');\nvar util = require('./util');\nvar nInstances = 0;\n/**\n * {@link NetworkQualityLevel} is a value from 0–5, inclusive, representing the\n * quality of a network connection.\n * @typedef {number} NetworkQualityLevel\n */\n/**\n * @extends EventEmitter\n * @property {Map<Track.SID, AudioTrackPublication>} audioTracks -\n *    The {@link Participant}'s {@link AudioTrackPublication}s\n * @property {Map<Track.SID, DataTrackPublication>} dataTracks -\n *    The {@link Participant}'s {@link DataTrackPublication}s.\n * @property {Participant.Identity} identity - The identity of the {@link Participant}\n * @property {?NetworkQualityLevel} networkQualityLevel - The\n *    {@link Participant}'s current {@link NetworkQualityLevel}, if any\n * @property {?NetworkQualityStats} networkQualityStats - The\n *    {@link Participant}'s current {@link NetworkQualityStats}, if any\n * @property {Participant.SID} sid - The {@link Participant}'s SID\n * @property {string} state - \"connected\", \"disconnected\" or \"reconnecting\"\n * @property {Map<Track.SID, TrackPublication>} tracks -\n *    The {@link Participant}'s {@link TrackPublication}s\n * @property {Map<Track.SID, VideoTrackPublication>} videoTracks -\n *    The {@link Participant}'s {@link VideoTrackPublication}s\n * @emits Participant#disconnected\n * @emits Participant#networkQualityLevelChanged\n * @emits Participant#reconnected\n * @emits Participant#reconnecting\n * @emits Participant#trackDimensionsChanged\n * @emits Participant#trackStarted\n */\nvar Participant = /** @class */function (_super) {\n  __extends(Participant, _super);\n  /**\n   * Construct a {@link Participant}.\n   * @param {ParticipantSignaling} signaling\n   * @param {object} [options]\n   */\n  function Participant(signaling, options) {\n    var _this = _super.call(this) || this;\n    options = Object.assign({\n      RemoteAudioTrack: RemoteAudioTrack,\n      RemoteAudioTrackPublication: RemoteAudioTrackPublication,\n      RemoteDataTrack: RemoteDataTrack,\n      RemoteDataTrackPublication: RemoteDataTrackPublication,\n      RemoteVideoTrack: RemoteVideoTrack,\n      RemoteVideoTrackPublication: RemoteVideoTrackPublication,\n      tracks: []\n    }, options);\n    var indexed = indexTracksById(options.tracks);\n    var log = options.log.createLog('default', _this);\n    var audioTracks = new Map(indexed.audioTracks);\n    var dataTracks = new Map(indexed.dataTracks);\n    var tracks = new Map(indexed.tracks);\n    var videoTracks = new Map(indexed.videoTracks);\n    Object.defineProperties(_this, {\n      _RemoteAudioTrack: {\n        value: options.RemoteAudioTrack\n      },\n      _RemoteAudioTrackPublication: {\n        value: options.RemoteAudioTrackPublication\n      },\n      _RemoteDataTrack: {\n        value: options.RemoteDataTrack\n      },\n      _RemoteDataTrackPublication: {\n        value: options.RemoteDataTrackPublication\n      },\n      _RemoteVideoTrack: {\n        value: options.RemoteVideoTrack\n      },\n      _RemoteVideoTrackPublication: {\n        value: options.RemoteVideoTrackPublication\n      },\n      _audioTracks: {\n        value: audioTracks\n      },\n      _dataTracks: {\n        value: dataTracks\n      },\n      _instanceId: {\n        value: ++nInstances\n      },\n      _clientTrackSwitchOffControl: {\n        value: options.clientTrackSwitchOffControl\n      },\n      _contentPreferencesMode: {\n        value: options.contentPreferencesMode\n      },\n      _log: {\n        value: log\n      },\n      _signaling: {\n        value: signaling\n      },\n      _tracks: {\n        value: tracks\n      },\n      _trackEventReemitters: {\n        value: new Map()\n      },\n      _trackPublicationEventReemitters: {\n        value: new Map()\n      },\n      _trackSignalingUpdatedEventCallbacks: {\n        value: new Map()\n      },\n      _videoTracks: {\n        value: videoTracks\n      },\n      audioTracks: {\n        enumerable: true,\n        value: new Map()\n      },\n      dataTracks: {\n        enumerable: true,\n        value: new Map()\n      },\n      identity: {\n        enumerable: true,\n        get: function () {\n          return signaling.identity;\n        }\n      },\n      networkQualityLevel: {\n        enumerable: true,\n        get: function () {\n          return signaling.networkQualityLevel;\n        }\n      },\n      networkQualityStats: {\n        enumerable: true,\n        get: function () {\n          return signaling.networkQualityStats;\n        }\n      },\n      sid: {\n        enumerable: true,\n        get: function () {\n          return signaling.sid;\n        }\n      },\n      state: {\n        enumerable: true,\n        get: function () {\n          return signaling.state;\n        }\n      },\n      tracks: {\n        enumerable: true,\n        value: new Map()\n      },\n      videoTracks: {\n        enumerable: true,\n        value: new Map()\n      }\n    });\n    _this._tracks.forEach(reemitTrackEvents.bind(null, _this));\n    signaling.on('networkQualityLevelChanged', function () {\n      return _this.emit('networkQualityLevelChanged', _this.networkQualityLevel, _this.networkQualityStats && (_this.networkQualityStats.audio || _this.networkQualityStats.video) ? _this.networkQualityStats : null);\n    });\n    reemitSignalingStateChangedEvents(_this, signaling);\n    log.info(\"Created a new Participant\" + (_this.identity ? \": \" + _this.identity : ''));\n    return _this;\n  }\n  /**\n   * Get the {@link RemoteTrack} events to re-emit.\n   * @private\n   * @returns {Array<Array<string>>} events\n   */\n  Participant.prototype._getTrackEvents = function () {\n    return [['dimensionsChanged', 'trackDimensionsChanged'], ['message', 'trackMessage'], ['started', 'trackStarted']];\n  };\n  /**\n   * @private\n   */\n  Participant.prototype._getTrackPublicationEvents = function () {\n    return [];\n  };\n  Participant.prototype.toString = function () {\n    return \"[Participant #\" + this._instanceId + \": \" + this.sid + \"]\";\n  };\n  /**\n   * @private\n   * @param {RemoteTrack} track\n   * @param {Track.ID} id\n   * @returns {?RemoteTrack}\n   */\n  Participant.prototype._addTrack = function (track, id) {\n    var log = this._log;\n    if (this._tracks.has(id)) {\n      return null;\n    }\n    this._tracks.set(id, track);\n    var tracksByKind = {\n      audio: this._audioTracks,\n      video: this._videoTracks,\n      data: this._dataTracks\n    }[track.kind];\n    tracksByKind.set(id, track);\n    reemitTrackEvents(this, track, id);\n    log.info(\"Added a new \" + util.trackClass(track) + \":\", id);\n    log.debug(util.trackClass(track) + \":\", track);\n    return track;\n  };\n  /**\n   * @private\n   * @param {RemoteTrackPublication} publication\n   * @returns {?RemoteTrackPublication}\n   */\n  Participant.prototype._addTrackPublication = function (publication) {\n    var log = this._log;\n    if (this.tracks.has(publication.trackSid)) {\n      return null;\n    }\n    this.tracks.set(publication.trackSid, publication);\n    var trackPublicationsByKind = {\n      audio: this.audioTracks,\n      data: this.dataTracks,\n      video: this.videoTracks\n    }[publication.kind];\n    trackPublicationsByKind.set(publication.trackSid, publication);\n    reemitTrackPublicationEvents(this, publication);\n    log.info(\"Added a new \" + util.trackPublicationClass(publication) + \":\", publication.trackSid);\n    log.debug(util.trackPublicationClass(publication) + \":\", publication);\n    return publication;\n  };\n  /**\n   * @private\n   */\n  Participant.prototype._handleTrackSignalingEvents = function () {\n    var _a = this,\n      log = _a._log,\n      clientTrackSwitchOffControl = _a._clientTrackSwitchOffControl,\n      contentPreferencesMode = _a._contentPreferencesMode;\n    var self = this;\n    if (this.state === 'disconnected') {\n      return;\n    }\n    var RemoteAudioTrack = this._RemoteAudioTrack;\n    var RemoteAudioTrackPublication = this._RemoteAudioTrackPublication;\n    var RemoteVideoTrack = this._RemoteVideoTrack;\n    var RemoteVideoTrackPublication = this._RemoteVideoTrackPublication;\n    var RemoteDataTrack = this._RemoteDataTrack;\n    var RemoteDataTrackPublication = this._RemoteDataTrackPublication;\n    var participantSignaling = this._signaling;\n    function trackSignalingAdded(signaling) {\n      var RemoteTrackPublication = {\n        audio: RemoteAudioTrackPublication,\n        data: RemoteDataTrackPublication,\n        video: RemoteVideoTrackPublication\n      }[signaling.kind];\n      var publication = new RemoteTrackPublication(signaling, {\n        log: log\n      });\n      self._addTrackPublication(publication);\n      var isSubscribed = signaling.isSubscribed;\n      if (isSubscribed) {\n        trackSignalingSubscribed(signaling);\n      }\n      self._trackSignalingUpdatedEventCallbacks.set(signaling.sid, function () {\n        if (isSubscribed !== signaling.isSubscribed) {\n          isSubscribed = signaling.isSubscribed;\n          if (isSubscribed) {\n            trackSignalingSubscribed(signaling);\n            return;\n          }\n          trackSignalingUnsubscribed(signaling);\n        }\n      });\n      signaling.on('updated', self._trackSignalingUpdatedEventCallbacks.get(signaling.sid));\n    }\n    function trackSignalingRemoved(signaling) {\n      if (signaling.isSubscribed) {\n        signaling.setTrackTransceiver(null);\n      }\n      var updated = self._trackSignalingUpdatedEventCallbacks.get(signaling.sid);\n      if (updated) {\n        signaling.removeListener('updated', updated);\n        self._trackSignalingUpdatedEventCallbacks.delete(signaling.sid);\n      }\n      var publication = self.tracks.get(signaling.sid);\n      if (publication) {\n        self._removeTrackPublication(publication);\n      }\n    }\n    function trackSignalingSubscribed(signaling) {\n      var isEnabled = signaling.isEnabled,\n        name = signaling.name,\n        kind = signaling.kind,\n        sid = signaling.sid,\n        trackTransceiver = signaling.trackTransceiver,\n        isSwitchedOff = signaling.isSwitchedOff;\n      var RemoteTrack = {\n        audio: RemoteAudioTrack,\n        video: RemoteVideoTrack,\n        data: RemoteDataTrack\n      }[kind];\n      var publication = self.tracks.get(sid);\n      // NOTE(mroberts): It should never be the case that the TrackSignaling and\n      // MediaStreamTrack or DataTrackReceiver kinds disagree; however, just in\n      // case, we handle it here.\n      if (!RemoteTrack || kind !== trackTransceiver.kind) {\n        return;\n      }\n      var options = {\n        log: log,\n        name: name,\n        clientTrackSwitchOffControl: clientTrackSwitchOffControl,\n        contentPreferencesMode: contentPreferencesMode\n      };\n      var setPriority = function (newPriority) {\n        return participantSignaling.updateSubscriberTrackPriority(sid, newPriority);\n      };\n      var setRenderHint = function (renderHint) {\n        if (signaling.isSubscribed) {\n          participantSignaling.updateTrackRenderHint(sid, renderHint);\n        }\n      };\n      var track = kind === 'data' ? new RemoteTrack(sid, trackTransceiver, options) : new RemoteTrack(sid, trackTransceiver, isEnabled, isSwitchedOff, setPriority, setRenderHint, options);\n      self._addTrack(track, publication, trackTransceiver.id);\n    }\n    function trackSignalingUnsubscribed(signaling) {\n      var _a = __read(Array.from(self._tracks.entries()).find(function (_a) {\n          var _b = __read(_a, 2),\n            track = _b[1];\n          return track.sid === signaling.sid;\n        }), 2),\n        id = _a[0],\n        track = _a[1];\n      var publication = self.tracks.get(signaling.sid);\n      if (track) {\n        self._removeTrack(track, publication, id);\n      }\n    }\n    participantSignaling.on('trackAdded', trackSignalingAdded);\n    participantSignaling.on('trackRemoved', trackSignalingRemoved);\n    participantSignaling.tracks.forEach(trackSignalingAdded);\n    participantSignaling.on('stateChanged', function stateChanged(state) {\n      if (state === 'disconnected') {\n        log.debug('Removing event listeners');\n        participantSignaling.removeListener('stateChanged', stateChanged);\n        participantSignaling.removeListener('trackAdded', trackSignalingAdded);\n        participantSignaling.removeListener('trackRemoved', trackSignalingRemoved);\n      } else if (state === 'connected') {\n        // NOTE(mmalavalli): Any transition to \"connected\" here is a result of\n        // successful signaling reconnection, and not a first-time establishment\n        // of the signaling connection.\n        log.info('reconnected');\n        // NOTE(mpatwardhan): `stateChanged` can get emitted with StateMachine locked.\n        // Do not signal  public events synchronously with lock held.\n        setTimeout(function () {\n          return self.emit('reconnected');\n        }, 0);\n      }\n    });\n  };\n  /**\n   * @private\n   * @param {RemoteTrack} track\n   * @param {Track.ID} id\n   * @returns {?RemoteTrack}\n   */\n  Participant.prototype._removeTrack = function (track, id) {\n    if (!this._tracks.has(id)) {\n      return null;\n    }\n    this._tracks.delete(id);\n    var tracksByKind = {\n      audio: this._audioTracks,\n      video: this._videoTracks,\n      data: this._dataTracks\n    }[track.kind];\n    tracksByKind.delete(id);\n    var reemitters = this._trackEventReemitters.get(id) || new Map();\n    reemitters.forEach(function (reemitter, event) {\n      track.removeListener(event, reemitter);\n    });\n    var log = this._log;\n    log.info(\"Removed a \" + util.trackClass(track) + \":\", id);\n    log.debug(util.trackClass(track) + \":\", track);\n    return track;\n  };\n  /**\n   * @private\n   * @param {RemoteTrackPublication} publication\n   * @returns {?RemoteTrackPublication}\n   */\n  Participant.prototype._removeTrackPublication = function (publication) {\n    publication = this.tracks.get(publication.trackSid);\n    if (!publication) {\n      return null;\n    }\n    this.tracks.delete(publication.trackSid);\n    var trackPublicationsByKind = {\n      audio: this.audioTracks,\n      data: this.dataTracks,\n      video: this.videoTracks\n    }[publication.kind];\n    trackPublicationsByKind.delete(publication.trackSid);\n    var reemitters = this._trackPublicationEventReemitters.get(publication.trackSid) || new Map();\n    reemitters.forEach(function (reemitter, event) {\n      publication.removeListener(event, reemitter);\n    });\n    var log = this._log;\n    log.info(\"Removed a \" + util.trackPublicationClass(publication) + \":\", publication.trackSid);\n    log.debug(util.trackPublicationClass(publication) + \":\", publication);\n    return publication;\n  };\n  Participant.prototype.toJSON = function () {\n    return util.valueToJSON(this);\n  };\n  return Participant;\n}(EventEmitter);\n/**\n * A {@link Participant.SID} is a 34-character string starting with \"PA\"\n * that uniquely identifies a {@link Participant}.\n * @type string\n * @typedef Participant.SID\n */\n/**\n * A {@link Participant.Identity} is a string that identifies a\n * {@link Participant}. You can think of it like a name.\n * @typedef {string} Participant.Identity\n */\n/**\n * The {@link Participant} has disconnected.\n * @param {Participant} participant - The {@link Participant} that disconnected.\n * @event Participant#disconnected\n */\n/**\n * The {@link Participant}'s {@link NetworkQualityLevel} changed.\n * @param {NetworkQualityLevel} networkQualityLevel - The new\n *   {@link NetworkQualityLevel}\n * @param {?NetworkQualityStats} networkQualityStats - The {@link NetworkQualityStats}\n *   based on which {@link NetworkQualityLevel} is calculated, if any\n * @event Participant#networkQualityLevelChanged\n */\n/**\n * The {@link Participant} has reconnected to the {@link Room} after a signaling connection disruption.\n * @event Participant#reconnected\n */\n/**\n * The {@link Participant} is reconnecting to the {@link Room} after a signaling connection disruption.\n * @event Participant#reconnecting\n */\n/**\n * One of the {@link Participant}'s {@link VideoTrack}'s dimensions changed.\n * @param {VideoTrack} track - The {@link VideoTrack} whose dimensions changed\n * @event Participant#trackDimensionsChanged\n */\n/**\n * One of the {@link Participant}'s {@link Track}s started.\n * @param {Track} track - The {@link Track} that started\n * @event Participant#trackStarted\n */\n/**\n * Indexed {@link Track}s by {@link Track.ID}.\n * @typedef {object} IndexedTracks\n * @property {Array<{0: Track.ID, 1: AudioTrack}>} audioTracks - Indexed\n *   {@link AudioTrack}s\n * @property {Array<{0: Track.ID, 1: DataTrack}>} dataTracks - Indexed\n *   {@link DataTrack}s\n * @property {Array<{0: Track.ID, 1: Track}>} tracks - Indexed {@link Track}s\n * @property {Array<{0: Track.ID, 1: VideoTrack}>} videoTracks - Indexed\n *   {@link VideoTrack}s\n * @private\n */\n/**\n * Index tracks by {@link Track.ID}.\n * @param {Array<Track>} tracks\n * @returns {IndexedTracks}\n * @private\n */\nfunction indexTracksById(tracks) {\n  var indexedTracks = tracks.map(function (track) {\n    return [track.id, track];\n  });\n  var indexedAudioTracks = indexedTracks.filter(function (keyValue) {\n    return keyValue[1].kind === 'audio';\n  });\n  var indexedVideoTracks = indexedTracks.filter(function (keyValue) {\n    return keyValue[1].kind === 'video';\n  });\n  var indexedDataTracks = indexedTracks.filter(function (keyValue) {\n    return keyValue[1].kind === 'data';\n  });\n  return {\n    audioTracks: indexedAudioTracks,\n    dataTracks: indexedDataTracks,\n    tracks: indexedTracks,\n    videoTracks: indexedVideoTracks\n  };\n}\n/**\n * Re-emit {@link ParticipantSignaling} 'stateChanged' events.\n * @param {Participant} participant\n * @param {ParticipantSignaling} signaling\n * @private\n */\nfunction reemitSignalingStateChangedEvents(participant, signaling) {\n  var log = participant._log;\n  if (participant.state === 'disconnected') {\n    return;\n  }\n  // Reemit state transition events from the ParticipantSignaling.\n  signaling.on('stateChanged', function stateChanged(state) {\n    log.debug('Transitioned to state:', state);\n    participant.emit(state, participant);\n    if (state === 'disconnected') {\n      log.debug('Removing Track event reemitters');\n      signaling.removeListener('stateChanged', stateChanged);\n      participant._tracks.forEach(function (track) {\n        var reemitters = participant._trackEventReemitters.get(track.id);\n        if (track && reemitters) {\n          reemitters.forEach(function (reemitter, event) {\n            track.removeListener(event, reemitter);\n          });\n        }\n      });\n      // eslint-disable-next-line no-warning-comments\n      // TODO(joma): Removing this introduced unit test failures in the RemoteParticipant.\n      // Investigate further before removing.\n      signaling.tracks.forEach(function (trackSignaling) {\n        var track = participant._tracks.get(trackSignaling.id);\n        var reemitters = participant._trackEventReemitters.get(trackSignaling.id);\n        if (track && reemitters) {\n          reemitters.forEach(function (reemitter, event) {\n            track.removeListener(event, reemitter);\n          });\n        }\n      });\n      participant._trackEventReemitters.clear();\n      participant.tracks.forEach(function (publication) {\n        participant._trackPublicationEventReemitters.get(publication.trackSid).forEach(function (reemitter, event) {\n          publication.removeListener(event, reemitter);\n        });\n      });\n      participant._trackPublicationEventReemitters.clear();\n    }\n  });\n}\n/**\n * Re-emit {@link Track} events.\n * @param {Participant} participant\n * @param {Track} track\n * @param {Track.ID} id\n * @private\n */\nfunction reemitTrackEvents(participant, track, id) {\n  var trackEventReemitters = new Map();\n  if (participant.state === 'disconnected') {\n    return;\n  }\n  participant._getTrackEvents().forEach(function (eventPair) {\n    var trackEvent = eventPair[0];\n    var participantEvent = eventPair[1];\n    trackEventReemitters.set(trackEvent, function () {\n      var args = [participantEvent].concat([].slice.call(arguments));\n      return participant.emit.apply(participant, __spreadArray([], __read(args)));\n    });\n    track.on(trackEvent, trackEventReemitters.get(trackEvent));\n  });\n  participant._trackEventReemitters.set(id, trackEventReemitters);\n}\n/**\n * Re-emit {@link TrackPublication} events.\n * @private\n * @param {Participant} participant\n * @param {TrackPublication} publication\n */\nfunction reemitTrackPublicationEvents(participant, publication) {\n  var publicationEventReemitters = new Map();\n  if (participant.state === 'disconnected') {\n    return;\n  }\n  participant._getTrackPublicationEvents().forEach(function (_a) {\n    var _b = __read(_a, 2),\n      publicationEvent = _b[0],\n      participantEvent = _b[1];\n    publicationEventReemitters.set(publicationEvent, function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      participant.emit.apply(participant, __spreadArray(__spreadArray([participantEvent], __read(args)), [publication]));\n    });\n    publication.on(publicationEvent, publicationEventReemitters.get(publicationEvent));\n  });\n  participant._trackPublicationEventReemitters.set(publication.trackSid, publicationEventReemitters);\n}\nmodule.exports = Participant;","map":{"version":3,"mappings":"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","names":["EventEmitter","require","RemoteAudioTrack","RemoteAudioTrackPublication","RemoteDataTrack","RemoteDataTrackPublication","RemoteVideoTrack","RemoteVideoTrackPublication","util","nInstances","__extends","signaling","options","_super","Object","assign","tracks","indexed","indexTracksById","log","createLog","_this","audioTracks","Map","dataTracks","videoTracks","defineProperties","_RemoteAudioTrack","value","_RemoteAudioTrackPublication","_RemoteDataTrack","_RemoteDataTrackPublication","_RemoteVideoTrack","_RemoteVideoTrackPublication","_audioTracks","_dataTracks","_instanceId","_clientTrackSwitchOffControl","clientTrackSwitchOffControl","_contentPreferencesMode","contentPreferencesMode","_log","_signaling","_tracks","_trackEventReemitters","_trackPublicationEventReemitters","_trackSignalingUpdatedEventCallbacks","_videoTracks","enumerable","identity","get","networkQualityLevel","networkQualityStats","sid","state","forEach","reemitTrackEvents","bind","on","emit","audio","video","reemitSignalingStateChangedEvents","info","Participant","track","id","has","set","tracksByKind","data","kind","trackClass","debug","publication","trackSid","trackPublicationsByKind","reemitTrackPublicationEvents","trackPublicationClass","self","participantSignaling","trackSignalingAdded","RemoteTrackPublication","_addTrackPublication","isSubscribed","trackSignalingSubscribed","trackSignalingUnsubscribed","trackSignalingRemoved","setTrackTransceiver","updated","removeListener","delete","_removeTrackPublication","name","trackTransceiver","isSwitchedOff","RemoteTrack","setPriority","updateSubscriberTrackPriority","newPriority","setRenderHint","updateTrackRenderHint","renderHint","isEnabled","_addTrack","Array","from","entries","find","_a","_b","_removeTrack","stateChanged","setTimeout","reemitters","reemitter","event","valueToJSON","indexedTracks","map","indexedAudioTracks","filter","indexedVideoTracks","indexedDataTracks","participant","trackSignaling","clear","trackEventReemitters","_getTrackEvents","trackEvent","eventPair","participantEvent","args","concat","slice","call","arguments","publicationEventReemitters","_getTrackPublicationEvents","publicationEvent","_i","module","exports"],"sources":["/Users/aarushisingh/Projects/counteroffer/client/node_modules/twilio-video/lib/participant.js"],"sourcesContent":["'use strict';\n\nconst EventEmitter = require('./eventemitter');\nconst RemoteAudioTrack = require('./media/track/remoteaudiotrack');\nconst RemoteAudioTrackPublication = require('./media/track/remoteaudiotrackpublication');\nconst RemoteDataTrack = require('./media/track/remotedatatrack');\nconst RemoteDataTrackPublication = require('./media/track/remotedatatrackpublication');\nconst RemoteVideoTrack = require('./media/track/remotevideotrack');\nconst RemoteVideoTrackPublication = require('./media/track/remotevideotrackpublication');\nconst util = require('./util');\n\nlet nInstances = 0;\n\n/**\n * {@link NetworkQualityLevel} is a value from 0–5, inclusive, representing the\n * quality of a network connection.\n * @typedef {number} NetworkQualityLevel\n */\n\n/**\n * @extends EventEmitter\n * @property {Map<Track.SID, AudioTrackPublication>} audioTracks -\n *    The {@link Participant}'s {@link AudioTrackPublication}s\n * @property {Map<Track.SID, DataTrackPublication>} dataTracks -\n *    The {@link Participant}'s {@link DataTrackPublication}s.\n * @property {Participant.Identity} identity - The identity of the {@link Participant}\n * @property {?NetworkQualityLevel} networkQualityLevel - The\n *    {@link Participant}'s current {@link NetworkQualityLevel}, if any\n * @property {?NetworkQualityStats} networkQualityStats - The\n *    {@link Participant}'s current {@link NetworkQualityStats}, if any\n * @property {Participant.SID} sid - The {@link Participant}'s SID\n * @property {string} state - \"connected\", \"disconnected\" or \"reconnecting\"\n * @property {Map<Track.SID, TrackPublication>} tracks -\n *    The {@link Participant}'s {@link TrackPublication}s\n * @property {Map<Track.SID, VideoTrackPublication>} videoTracks -\n *    The {@link Participant}'s {@link VideoTrackPublication}s\n * @emits Participant#disconnected\n * @emits Participant#networkQualityLevelChanged\n * @emits Participant#reconnected\n * @emits Participant#reconnecting\n * @emits Participant#trackDimensionsChanged\n * @emits Participant#trackStarted\n */\nclass Participant extends EventEmitter {\n  /**\n   * Construct a {@link Participant}.\n   * @param {ParticipantSignaling} signaling\n   * @param {object} [options]\n   */\n  constructor(signaling, options) {\n    super();\n\n    options = Object.assign({\n      RemoteAudioTrack,\n      RemoteAudioTrackPublication,\n      RemoteDataTrack,\n      RemoteDataTrackPublication,\n      RemoteVideoTrack,\n      RemoteVideoTrackPublication,\n      tracks: []\n    }, options);\n\n    const indexed = indexTracksById(options.tracks);\n    const log = options.log.createLog('default', this);\n    const audioTracks = new Map(indexed.audioTracks);\n    const dataTracks = new Map(indexed.dataTracks);\n    const tracks = new Map(indexed.tracks);\n    const videoTracks = new Map(indexed.videoTracks);\n\n    Object.defineProperties(this, {\n      _RemoteAudioTrack: {\n        value: options.RemoteAudioTrack\n      },\n      _RemoteAudioTrackPublication: {\n        value: options.RemoteAudioTrackPublication\n      },\n      _RemoteDataTrack: {\n        value: options.RemoteDataTrack\n      },\n      _RemoteDataTrackPublication: {\n        value: options.RemoteDataTrackPublication\n      },\n      _RemoteVideoTrack: {\n        value: options.RemoteVideoTrack\n      },\n      _RemoteVideoTrackPublication: {\n        value: options.RemoteVideoTrackPublication\n      },\n      _audioTracks: {\n        value: audioTracks\n      },\n      _dataTracks: {\n        value: dataTracks\n      },\n      _instanceId: {\n        value: ++nInstances\n      },\n      _clientTrackSwitchOffControl: {\n        value: options.clientTrackSwitchOffControl,\n      },\n      _contentPreferencesMode: {\n        value: options.contentPreferencesMode,\n      },\n      _log: {\n        value: log\n      },\n      _signaling: {\n        value: signaling\n      },\n      _tracks: {\n        value: tracks\n      },\n      _trackEventReemitters: {\n        value: new Map()\n      },\n      _trackPublicationEventReemitters: {\n        value: new Map()\n      },\n      _trackSignalingUpdatedEventCallbacks: {\n        value: new Map()\n      },\n      _videoTracks: {\n        value: videoTracks\n      },\n      audioTracks: {\n        enumerable: true,\n        value: new Map()\n      },\n      dataTracks: {\n        enumerable: true,\n        value: new Map()\n      },\n      identity: {\n        enumerable: true,\n        get() {\n          return signaling.identity;\n        }\n      },\n      networkQualityLevel: {\n        enumerable: true,\n        get() {\n          return signaling.networkQualityLevel;\n        }\n      },\n      networkQualityStats: {\n        enumerable: true,\n        get() {\n          return signaling.networkQualityStats;\n        }\n      },\n      sid: {\n        enumerable: true,\n        get() {\n          return signaling.sid;\n        }\n      },\n      state: {\n        enumerable: true,\n        get() {\n          return signaling.state;\n        }\n      },\n      tracks: {\n        enumerable: true,\n        value: new Map()\n      },\n      videoTracks: {\n        enumerable: true,\n        value: new Map()\n      }\n    });\n\n    this._tracks.forEach(reemitTrackEvents.bind(null, this));\n    signaling.on('networkQualityLevelChanged', () =>\n      this.emit('networkQualityLevelChanged', this.networkQualityLevel,\n        this.networkQualityStats &&\n        (this.networkQualityStats.audio || this.networkQualityStats.video)\n          ? this.networkQualityStats\n          : null));\n    reemitSignalingStateChangedEvents(this, signaling);\n    log.info(`Created a new Participant${this.identity ? `: ${this.identity}` : ''}`);\n  }\n\n  /**\n   * Get the {@link RemoteTrack} events to re-emit.\n   * @private\n   * @returns {Array<Array<string>>} events\n   */\n  _getTrackEvents() {\n    return [\n      ['dimensionsChanged', 'trackDimensionsChanged'],\n      ['message', 'trackMessage'],\n      ['started', 'trackStarted']\n    ];\n  }\n\n  /**\n   * @private\n   */\n  _getTrackPublicationEvents() {\n    return [];\n  }\n\n  toString() {\n    return `[Participant #${this._instanceId}: ${this.sid}]`;\n  }\n\n  /**\n   * @private\n   * @param {RemoteTrack} track\n   * @param {Track.ID} id\n   * @returns {?RemoteTrack}\n   */\n  _addTrack(track, id) {\n    const log = this._log;\n    if (this._tracks.has(id)) {\n      return null;\n    }\n    this._tracks.set(id, track);\n\n    const tracksByKind = {\n      audio: this._audioTracks,\n      video: this._videoTracks,\n      data: this._dataTracks\n    }[track.kind];\n    tracksByKind.set(id, track);\n    reemitTrackEvents(this, track, id);\n\n    log.info(`Added a new ${util.trackClass(track)}:`, id);\n    log.debug(`${util.trackClass(track)}:`, track);\n\n    return track;\n  }\n\n\n  /**\n   * @private\n   * @param {RemoteTrackPublication} publication\n   * @returns {?RemoteTrackPublication}\n   */\n  _addTrackPublication(publication) {\n    const log = this._log;\n    if (this.tracks.has(publication.trackSid)) {\n      return null;\n    }\n    this.tracks.set(publication.trackSid, publication);\n\n    const trackPublicationsByKind = {\n      audio: this.audioTracks,\n      data: this.dataTracks,\n      video: this.videoTracks\n    }[publication.kind];\n    trackPublicationsByKind.set(publication.trackSid, publication);\n    reemitTrackPublicationEvents(this, publication);\n\n    log.info(`Added a new ${util.trackPublicationClass(publication)}:`, publication.trackSid);\n    log.debug(`${util.trackPublicationClass(publication)}:`, publication);\n    return publication;\n  }\n\n  /**\n   * @private\n   */\n  _handleTrackSignalingEvents() {\n    const { _log: log, _clientTrackSwitchOffControl: clientTrackSwitchOffControl, _contentPreferencesMode: contentPreferencesMode } = this;\n    const self = this;\n\n    if (this.state === 'disconnected') {\n      return;\n    }\n\n    const RemoteAudioTrack = this._RemoteAudioTrack;\n    const RemoteAudioTrackPublication = this._RemoteAudioTrackPublication;\n    const RemoteVideoTrack = this._RemoteVideoTrack;\n    const RemoteVideoTrackPublication = this._RemoteVideoTrackPublication;\n    const RemoteDataTrack = this._RemoteDataTrack;\n    const RemoteDataTrackPublication = this._RemoteDataTrackPublication;\n    const participantSignaling = this._signaling;\n\n    function trackSignalingAdded(signaling) {\n      const RemoteTrackPublication = {\n        audio: RemoteAudioTrackPublication,\n        data: RemoteDataTrackPublication,\n        video: RemoteVideoTrackPublication\n      }[signaling.kind];\n\n      const publication = new RemoteTrackPublication(signaling, { log });\n      self._addTrackPublication(publication);\n\n      let isSubscribed = signaling.isSubscribed;\n      if (isSubscribed) {\n        trackSignalingSubscribed(signaling);\n      }\n\n      self._trackSignalingUpdatedEventCallbacks.set(signaling.sid, () => {\n        if (isSubscribed !== signaling.isSubscribed) {\n          isSubscribed = signaling.isSubscribed;\n          if (isSubscribed) {\n            trackSignalingSubscribed(signaling);\n            return;\n          }\n          trackSignalingUnsubscribed(signaling);\n        }\n      });\n      signaling.on('updated', self._trackSignalingUpdatedEventCallbacks.get(signaling.sid));\n    }\n\n    function trackSignalingRemoved(signaling) {\n      if (signaling.isSubscribed) {\n        signaling.setTrackTransceiver(null);\n      }\n      const updated = self._trackSignalingUpdatedEventCallbacks.get(signaling.sid);\n      if (updated) {\n        signaling.removeListener('updated', updated);\n        self._trackSignalingUpdatedEventCallbacks.delete(signaling.sid);\n      }\n      const publication = self.tracks.get(signaling.sid);\n      if (publication) {\n        self._removeTrackPublication(publication);\n      }\n    }\n\n    function trackSignalingSubscribed(signaling) {\n      const { isEnabled, name, kind, sid, trackTransceiver, isSwitchedOff } = signaling;\n      const RemoteTrack = {\n        audio: RemoteAudioTrack,\n        video: RemoteVideoTrack,\n        data: RemoteDataTrack\n      }[kind];\n\n      const publication = self.tracks.get(sid);\n\n      // NOTE(mroberts): It should never be the case that the TrackSignaling and\n      // MediaStreamTrack or DataTrackReceiver kinds disagree; however, just in\n      // case, we handle it here.\n      if (!RemoteTrack || kind !== trackTransceiver.kind) {\n        return;\n      }\n\n      const options = { log, name, clientTrackSwitchOffControl, contentPreferencesMode };\n      const setPriority = newPriority => participantSignaling.updateSubscriberTrackPriority(sid, newPriority);\n      const setRenderHint = renderHint => {\n        if (signaling.isSubscribed) {\n          participantSignaling.updateTrackRenderHint(sid, renderHint);\n        }\n      };\n      const track = kind === 'data'\n        ? new RemoteTrack(sid, trackTransceiver, options)\n        : new RemoteTrack(sid, trackTransceiver, isEnabled, isSwitchedOff, setPriority, setRenderHint, options);\n\n      self._addTrack(track, publication, trackTransceiver.id);\n    }\n\n    function trackSignalingUnsubscribed(signaling) {\n      const [id, track] = Array.from(self._tracks.entries()).find(([, track]) => track.sid === signaling.sid);\n      const publication = self.tracks.get(signaling.sid);\n      if (track) {\n        self._removeTrack(track, publication, id);\n      }\n    }\n\n    participantSignaling.on('trackAdded', trackSignalingAdded);\n    participantSignaling.on('trackRemoved', trackSignalingRemoved);\n\n    participantSignaling.tracks.forEach(trackSignalingAdded);\n\n    participantSignaling.on('stateChanged', function stateChanged(state) {\n      if (state === 'disconnected') {\n        log.debug('Removing event listeners');\n        participantSignaling.removeListener('stateChanged', stateChanged);\n        participantSignaling.removeListener('trackAdded', trackSignalingAdded);\n        participantSignaling.removeListener('trackRemoved', trackSignalingRemoved);\n      } else if (state === 'connected') {\n        // NOTE(mmalavalli): Any transition to \"connected\" here is a result of\n        // successful signaling reconnection, and not a first-time establishment\n        // of the signaling connection.\n        log.info('reconnected');\n\n        // NOTE(mpatwardhan): `stateChanged` can get emitted with StateMachine locked.\n        // Do not signal  public events synchronously with lock held.\n        setTimeout(() => self.emit('reconnected'), 0);\n\n      }\n    });\n  }\n\n  /**\n   * @private\n   * @param {RemoteTrack} track\n   * @param {Track.ID} id\n   * @returns {?RemoteTrack}\n   */\n  _removeTrack(track, id) {\n    if (!this._tracks.has(id)) {\n      return null;\n    }\n    this._tracks.delete(id);\n\n    const tracksByKind = {\n      audio: this._audioTracks,\n      video: this._videoTracks,\n      data: this._dataTracks\n    }[track.kind];\n    tracksByKind.delete(id);\n\n    const reemitters = this._trackEventReemitters.get(id) || new Map();\n    reemitters.forEach((reemitter, event) => {\n      track.removeListener(event, reemitter);\n    });\n\n    const log = this._log;\n    log.info(`Removed a ${util.trackClass(track)}:`, id);\n    log.debug(`${util.trackClass(track)}:`, track);\n    return track;\n  }\n\n  /**\n   * @private\n   * @param {RemoteTrackPublication} publication\n   * @returns {?RemoteTrackPublication}\n   */\n  _removeTrackPublication(publication) {\n    publication = this.tracks.get(publication.trackSid);\n    if (!publication) {\n      return null;\n    }\n    this.tracks.delete(publication.trackSid);\n\n    const trackPublicationsByKind = {\n      audio: this.audioTracks,\n      data: this.dataTracks,\n      video: this.videoTracks\n    }[publication.kind];\n    trackPublicationsByKind.delete(publication.trackSid);\n\n    const reemitters = this._trackPublicationEventReemitters.get(publication.trackSid) || new Map();\n    reemitters.forEach((reemitter, event) => {\n      publication.removeListener(event, reemitter);\n    });\n\n    const log = this._log;\n    log.info(`Removed a ${util.trackPublicationClass(publication)}:`, publication.trackSid);\n    log.debug(`${util.trackPublicationClass(publication)}:`, publication);\n    return publication;\n  }\n\n  toJSON() {\n    return util.valueToJSON(this);\n  }\n}\n\n/**\n * A {@link Participant.SID} is a 34-character string starting with \"PA\"\n * that uniquely identifies a {@link Participant}.\n * @type string\n * @typedef Participant.SID\n */\n\n/**\n * A {@link Participant.Identity} is a string that identifies a\n * {@link Participant}. You can think of it like a name.\n * @typedef {string} Participant.Identity\n */\n\n/**\n * The {@link Participant} has disconnected.\n * @param {Participant} participant - The {@link Participant} that disconnected.\n * @event Participant#disconnected\n */\n\n/**\n * The {@link Participant}'s {@link NetworkQualityLevel} changed.\n * @param {NetworkQualityLevel} networkQualityLevel - The new\n *   {@link NetworkQualityLevel}\n * @param {?NetworkQualityStats} networkQualityStats - The {@link NetworkQualityStats}\n *   based on which {@link NetworkQualityLevel} is calculated, if any\n * @event Participant#networkQualityLevelChanged\n */\n\n/**\n * The {@link Participant} has reconnected to the {@link Room} after a signaling connection disruption.\n * @event Participant#reconnected\n */\n\n/**\n * The {@link Participant} is reconnecting to the {@link Room} after a signaling connection disruption.\n * @event Participant#reconnecting\n */\n\n/**\n * One of the {@link Participant}'s {@link VideoTrack}'s dimensions changed.\n * @param {VideoTrack} track - The {@link VideoTrack} whose dimensions changed\n * @event Participant#trackDimensionsChanged\n */\n\n/**\n * One of the {@link Participant}'s {@link Track}s started.\n * @param {Track} track - The {@link Track} that started\n * @event Participant#trackStarted\n */\n\n/**\n * Indexed {@link Track}s by {@link Track.ID}.\n * @typedef {object} IndexedTracks\n * @property {Array<{0: Track.ID, 1: AudioTrack}>} audioTracks - Indexed\n *   {@link AudioTrack}s\n * @property {Array<{0: Track.ID, 1: DataTrack}>} dataTracks - Indexed\n *   {@link DataTrack}s\n * @property {Array<{0: Track.ID, 1: Track}>} tracks - Indexed {@link Track}s\n * @property {Array<{0: Track.ID, 1: VideoTrack}>} videoTracks - Indexed\n *   {@link VideoTrack}s\n * @private\n */\n\n/**\n * Index tracks by {@link Track.ID}.\n * @param {Array<Track>} tracks\n * @returns {IndexedTracks}\n * @private\n */\nfunction indexTracksById(tracks) {\n  const indexedTracks = tracks.map(track => [track.id, track]);\n  const indexedAudioTracks = indexedTracks.filter(keyValue => keyValue[1].kind === 'audio');\n  const indexedVideoTracks = indexedTracks.filter(keyValue => keyValue[1].kind === 'video');\n  const indexedDataTracks = indexedTracks.filter(keyValue => keyValue[1].kind === 'data');\n\n  return {\n    audioTracks: indexedAudioTracks,\n    dataTracks: indexedDataTracks,\n    tracks: indexedTracks,\n    videoTracks: indexedVideoTracks\n  };\n}\n\n/**\n * Re-emit {@link ParticipantSignaling} 'stateChanged' events.\n * @param {Participant} participant\n * @param {ParticipantSignaling} signaling\n * @private\n */\nfunction reemitSignalingStateChangedEvents(participant, signaling) {\n  const log = participant._log;\n\n  if (participant.state === 'disconnected') {\n    return;\n  }\n\n  // Reemit state transition events from the ParticipantSignaling.\n  signaling.on('stateChanged', function stateChanged(state) {\n    log.debug('Transitioned to state:', state);\n    participant.emit(state, participant);\n    if (state === 'disconnected') {\n      log.debug('Removing Track event reemitters');\n      signaling.removeListener('stateChanged', stateChanged);\n\n      participant._tracks.forEach(track => {\n        const reemitters = participant._trackEventReemitters.get(track.id);\n        if (track && reemitters) {\n          reemitters.forEach((reemitter, event) => {\n            track.removeListener(event, reemitter);\n          });\n        }\n      });\n\n      // eslint-disable-next-line no-warning-comments\n      // TODO(joma): Removing this introduced unit test failures in the RemoteParticipant.\n      // Investigate further before removing.\n      signaling.tracks.forEach(trackSignaling => {\n        const track = participant._tracks.get(trackSignaling.id);\n        const reemitters = participant._trackEventReemitters.get(trackSignaling.id);\n        if (track && reemitters) {\n          reemitters.forEach((reemitter, event) => {\n            track.removeListener(event, reemitter);\n          });\n        }\n      });\n\n      participant._trackEventReemitters.clear();\n\n      participant.tracks.forEach(publication => {\n        participant._trackPublicationEventReemitters.get(publication.trackSid)\n          .forEach((reemitter, event) => {\n            publication.removeListener(event, reemitter);\n          });\n      });\n      participant._trackPublicationEventReemitters.clear();\n    }\n  });\n}\n\n/**\n * Re-emit {@link Track} events.\n * @param {Participant} participant\n * @param {Track} track\n * @param {Track.ID} id\n * @private\n */\nfunction reemitTrackEvents(participant, track, id) {\n  const trackEventReemitters = new Map();\n\n  if (participant.state === 'disconnected') {\n    return;\n  }\n\n  participant._getTrackEvents().forEach(eventPair => {\n    const trackEvent = eventPair[0];\n    const participantEvent = eventPair[1];\n\n    trackEventReemitters.set(trackEvent, function() {\n      const args = [participantEvent].concat([].slice.call(arguments));\n      return participant.emit(...args);\n    });\n\n    track.on(trackEvent, trackEventReemitters.get(trackEvent));\n  });\n\n  participant._trackEventReemitters.set(id, trackEventReemitters);\n}\n\n/**\n * Re-emit {@link TrackPublication} events.\n * @private\n * @param {Participant} participant\n * @param {TrackPublication} publication\n */\nfunction reemitTrackPublicationEvents(participant, publication) {\n  const publicationEventReemitters = new Map();\n\n  if (participant.state === 'disconnected') {\n    return;\n  }\n\n  participant._getTrackPublicationEvents().forEach(([publicationEvent, participantEvent]) => {\n    publicationEventReemitters.set(publicationEvent, (...args) => {\n      participant.emit(participantEvent, ...args, publication);\n    });\n    publication.on(publicationEvent, publicationEventReemitters.get(publicationEvent));\n  });\n\n  participant._trackPublicationEventReemitters.set(publication.trackSid, publicationEventReemitters);\n}\n\nmodule.exports = Participant;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}